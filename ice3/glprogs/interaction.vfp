!!ARBvp1.0 OPTION ARB_position_invariant;

TEMP R0, R1, R2;
PARAM defaultTexCoord = { 0, 0.5, 0, 1 };

# Calculate vector to light in R0
SUB R0, program.env[4], vertex.position;

# Put into texture space for TEX0
DP3 result.texcoord[0].x, vertex.attrib[9], R0;
DP3 result.texcoord[0].y, vertex.attrib[10], R0;
DP3 result.texcoord[0].z, vertex.attrib[11], R0;

# Textures 1 takes the base coordinates by the texture matrix
MOV result.texcoord[1], defaultTexCoord;
DP4 result.texcoord[1].x, vertex.attrib[8], program.env[10];
DP4 result.texcoord[1].y, vertex.attrib[8], program.env[11];

# Texture 2 has one texgen
MOV result.texcoord[2], defaultTexCoord;
DP4 result.texcoord[2].x, vertex.position, program.env[9];

# Texture 3 has three texgens
DP4 result.texcoord[3].x, vertex.position, program.env[6];
DP4 result.texcoord[3].y, vertex.position, program.env[7];
DP4 result.texcoord[3].w, vertex.position, program.env[8];

# Textures 4 takes the base coordinates by the texture matrix
MOV result.texcoord[4], defaultTexCoord;
DP4 result.texcoord[4].x, vertex.attrib[8], program.env[12];
DP4 result.texcoord[4].y, vertex.attrib[8], program.env[13];

# Textures 5 takes the base coordinates by the texture matrix
MOV result.texcoord[5], defaultTexCoord;
DP4 result.texcoord[5].x, vertex.attrib[8], program.env[14];
DP4 result.texcoord[5].y, vertex.attrib[8], program.env[15];

# Texture 6's texcoords will be the halfangle in texture space

# Calculate normalized vector to light in R0
SUB R0, program.env[4], vertex.position;
DP3 R1, R0, R0;
RSQ R1, R1.x;
MUL R0, R0, R1.x;

# Calculate normalized vector to viewer in R1
SUB R1, program.env[5], vertex.position;
DP3 R2, R1, R1;
RSQ R2, R2.x;
MUL R1, R1, R2.x;

# Add together to become the half angle vector in object space (non-normalized)
ADD R0, R0, R1;

# Put into texture space
DP3 result.texcoord[6].x, vertex.attrib[9], R0;
DP3 result.texcoord[6].y, vertex.attrib[10], R0;
DP3 result.texcoord[6].z, vertex.attrib[11], R0;

# Generate the vertex color, which can be 1.0, color, or 1.0 - color
# for 1.0 : env[16] = 0, env[17] = 1
# for color : env[16] = 1, env[17] = 0
# for 1.0-color : env[16] = -1, env[17] = 1
MAD result.color, vertex.color, program.env[16], program.env[17];

# Output the eye vector for offset mapping
SUB R0, vertex.position, program.env[5];
MOV result.texcoord[7], R0;

END

#======================================================================

!!ARBfp1.0 
OPTION ARB_precision_hint_fastest;

TEMP light, color, R1, R2, localNormal, specular, height, offsetCoord;

PARAM subOne = { -1, -1, -1, -1 };
PARAM scaleTwo = { 2, 2, 2, 2 };
PARAM heightScale = { 0.04, 0.04, 0.04, 0.04 };  # Adjust the height scale as needed

# Load the specular half angle first
DP3 specular, fragment.texcoord[6], fragment.texcoord[6];
RSQ specular, specular.x;
MUL specular, specular.x, fragment.texcoord[6];

# Perform the diffuse bump mapping
TEX light, fragment.texcoord[0], texture[0], CUBE;
MAD light, light, scaleTwo, subOne;

# Fetch the height from the height map (assuming texture[7] is the height map)
TEX height, fragment.texcoord[1], texture[7], 2D;

# Calculate the offset for parallax mapping
MUL height, height, heightScale;
SUB offsetCoord, fragment.texcoord[1], height;

# Fetch the normal map with the offset coordinates
TEX localNormal, offsetCoord, texture[1], 2D;
MOV localNormal.x, localNormal.a;
MAD localNormal, localNormal, scaleTwo, subOne;
DP3 light, light, localNormal;

# Modulate by the light projection
TXP R1, fragment.texcoord[3], texture[3], 2D;
MUL light, light, R1;

# Modulate by the light falloff
TXP R1, fragment.texcoord[2], texture[2], 2D;
MUL light, light, R1;

# Modulate by the diffuse map and constant diffuse factor
TEX R1, offsetCoord, texture[4], 2D;
MUL color, R1, program.env[0];

# Perform the specular bump mapping
DP3 specular, specular, localNormal;

# Perform a dependent table read for the specular falloff
TEX R1, specular, texture[6], 2D;

# Modulate by the constant specular factor
MUL R1, R1, program.env[1];

# Modulate by the specular map * 2
TEX R2, offsetCoord, texture[5], 2D;
ADD R2, R2, R2;
MAD color, R1, R2, color;

MUL color, light, color;

# Modify by the vertex color
MUL result.color, color, fragment.color;

END
